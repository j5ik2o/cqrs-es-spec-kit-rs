# アプリケーション要件

## 1. 背景と目的
- 本システムは `references/cqrs-es-example-rs` を基盤とした Rust 製 CQRS/ES バックエンドを中核に据え、クリーンアーキテクチャの原則を適用して拡張性とテスト容易性を担保する。
- Next.js フロントエンドと専用の Rust 製 GraphQL BFF サーバを分離し、フロント特有の要件とドメインロジックを明確に境界付ける。
- 認証は OAuth/OIDC を前提とし、BFF がリソースサーバとの間でトークン検証と権限制御を統括する。
- プロジェクト憲章（`.specify/memory/constitution.md`）に定義されたドメイン中心アーキテクチャ、仕様駆動開発、テストファーストの原則を順守する。

## 2. 全体アーキテクチャ

### 2.1 コンポーネント一覧
- **フロントエンド**: Next.js アプリ。React Server Components (RSC) とクライアントコンポーネントの双方で GraphQL クライアントを利用し、BFF から提供される Query/Mutation/Subscription を消費する。
- **BFF (Rust GraphQL Gateway)**: フロントエンド専用の GraphQL サーバ。Query は MySQL リードモデルを参照し、Mutation は別デプロイのコマンドアプリケーションサービスへ委譲し、Subscription でライブ更新を配信する。BFF 自身はコマンドのスケーリングやイベント処理を担わない。
- **コマンドアプリケーションサービス**: Rust 製バックエンドの独立システム。ユースケース層を通じてコマンド処理とイベントソーシングを行い、イベントストアへ永続化する。BFF からは内部 API（REST/gRPC 等）で呼び出され、フロントエンドから直接アクセスされない。
- **イベントストア**: DynamoDB。ドメインイベントとスナップショットの永続化を担当し、DynamoDB Streams で変更イベントを公開する。
- **イベントフォワーダー (Lambda)**: DynamoDB Streams を購読し、ストリームシーケンスを保持したまま Amazon Kinesis へイベントを転送する。順序保証とリトライ制御を担う。
- **イベントストリーム**: Amazon Kinesis。Lambda からの順序保証済みイベントをリードモデル更新サービスへ配信する。
- **リードモデル更新サービス (Lambda)**: Kinesis からイベントを取り込み、MySQL 上にリードモデルを構築・更新し、必要に応じて Redis 等へ通知を発行する。
- **リードモデル DB**: MySQL。BFF が GraphQL Query で参照する読み取りデータを保持。
- **リアルタイム通知基盤（任意）**: Redis Pub/Sub / Redis Streams / EventBridge など。Subscription のイベント配送や再送管理を支える。

### 2.2 データフロー概要
1. フロントエンドは GraphQL Client（RSC/クライアントコンポーネント）から BFF の Query/Mutation/Subscription を呼び出す。
2. Mutation 要求は BFF からサービス間ネットワーク経由でコマンドアプリケーションサービスへフォワードされ、ユースケース層でドメインロジックが実行される。
3. コマンド処理で生成されたドメインイベントは DynamoDB に保存され、直後に DynamoDB Streams へ反映される。
4. イベントフォワーダー Lambda が DynamoDB Streams を購読し、順序と到達保証を維持しながら Amazon Kinesis へイベントを転送する。
5. リードモデル更新サービス (Lambda) が Kinesis を購読し、MySQL のリードモデルを最新化すると同時に、必要に応じて Redis 等へ更新通知を発行する。
6. BFF の Query は MySQL を参照し、最新のリードモデルをレスポンスとして返す。
7. Subscription は BFF が Redis などの通知基盤を購読し、フロントエンドへライブ更新をプッシュする。クライアントは受信後に Query を再フェッチするかローカルキャッシュを更新する。

## 3. CQRS/ES 要件
- フロントエンドから露出する API は GraphQL に統一し、Mutation がコマンド、Query/Subscription がクエリ側の責務を担う。
- ドメインモデルはコマンドハンドラ中心に設計し、イベントソーシングを前提に不変条件を定義する。
- イベントスキーマは後方互換性を考慮し、バージョニング戦略とアップキャスト方針を策定してドキュメント化する。
- イベント再生によりリードモデルを任意時点で再構築できるよう、投影の冪等性とイベント順序保証を確保する。

## 4. コマンドアプリケーションサービス（CQRS コマンド側）
- `references/cqrs-es-example-rs` を起点に、クリーンアーキテクチャのレイヤリング（エンティティ、ユースケース、インターフェース、インフラストラクチャ）を維持する。
- `references/cqrs-es-example-rs/modules` のレイヤ構成と依存方向を踏襲し、差分が生じる場合は仕様で理由と影響を記録する。ドメイン層から外部依存への参照は禁止する。
- リポジトリやイベントストアポートはドメイン層または契約モジュールで宣言し、実装はインターフェースアダプタ層に閉じ込める。
- BFF からの外部 API 呼び出し（REST/gRPC など）に応答し、ユースケース層を通じて集約を再構築・検証し、イベントを生成する。
- 認証・認可は BFF 提供のアクセストークンを検証し、Resource Server として OAuth/OIDC のポリシーに従う。
- スナップショット戦略、イベント整合性チェック、イベント保存時のトランザクション管理を実装し、大量イベント時のリプレイコストを抑える。
- 参考リポジトリ `references/event-store-adapter-rs` を参照しつつ、設定はコードに散在させず設定ファイルへ集約する。

## 5. イベントフォワーダー & リードモデル更新サービス
- **イベントフォワーダー (Lambda)**: `lambda_runtime` と `aws_lambda_events` を用いて DynamoDB Streams イベントを受信し、`aws-sdk-kinesis` の `put_records` でシーケンス番号をパーティションキーとして Kinesis へ転送する。失敗レコードは再試行し、IAM 権限は最小限に保つ。
- **リードモデル更新サービス (Lambda)**: Kinesis イベントを `lambda_runtime` で処理し、`mysql_async` または `sqlx` から RDS Proxy 経由で MySQL 投影を更新する。イベント ID を処理履歴テーブルで管理して冪等性を確保する。
- **共通実装指針**: 両 Lambda とも `tracing` で構造化ログを出力し、環境変数で接続先やストリーム名を注入し、`cargo-lambda` によるビルド＆デプロイを前提とする（ローカル検証は `docs/local-sandbox.md` を参照）。
- Kinesis ストリームを購読する Lambda（または同等のイベント駆動実装）として構築し、イベントフォワーダーから受け取った順序を維持しながら処理する。
- MySQL リードモデルは投影単位で分離し、GraphQL Query からのアクセスパターンを基にスキーマ・インデックスを設計する。
- 冪等性を確保するためイベント ID トラッキングや処理状態テーブルを導入し、リプレイ時も同一結果を保証する。
- イベント処理遅延やバックログを監視し、閾値超過時はアラートを発報する。
- ライブ通知用途に Redis 等を利用する場合、投影完了後に更新情報をパブリッシュし、BFF がそれを購読できるようにする。
- DynamoDB Streams → Lambda → Kinesis → Lambda という多段構成で順序保証とリトライ制御を確立し、障害発生時にも一貫した投影状態を維持する。
- コマンド→イベント→投影の統合テストを自動化し、イベント再生とリードモデル復元の成立性を継続的に検証する。

## 6. BFF (Rust GraphQL Gateway)
- GraphQL Schema は Query/Mutation/Subscription を含み、フロントエンドと契約可能なスキーマバージョン管理を行う。
- Query Resolver は MySQL への接続プールを管理し、最小限の DTO 変換でリードモデルを返却する。
- Mutation Resolver はコマンドアプリケーションサービスへのネットワーク呼び出しを仲介し、コマンド結果・コリレーション ID など境界情報のみを返却する。BFF 自体はユースケースやイベント生成を保持しない。
- Subscription Resolver は Redis 等の通知基盤を購読し、クライアントへリアルタイムにイベントをプッシュする。接続維持と再接続戦略を実装する。
- OAuth/OIDC のトークン検証、ロールベース権限制御、監査ログの記録を BFF に集約し、コマンド/クエリで一貫性のあるポリシーを適用する。
- GraphQL エラーハンドリングと戻り値仕様を定義し、サービス間通信失敗時のリトライ・フェイルオーバー・フェイルファスト方針を明示する。

## 7. フロントエンド (Next.js)
- RSC では GraphQL Fetcher を通じて BFF の Query を呼び出し、SSR/RSC のキャッシング特性を活かす。クライアントコンポーネントは Suspense やキャッシュ層を用いてレスポンスを共有する。
- Mutation は Next.js の Server Actions やクライアント側ミューテーション関数から BFF の GraphQL Mutation を実行し、結果に応じてキャッシュ更新や再フェッチを行う。
- Subscription はクライアント側で WebSocket/GraphQL over WebSocket を利用し、受信イベントに応じてローカルストアを更新し、必要に応じて Query を再フェッチする。
- OIDC クライアント SDK を用いてアクセストークン・リフレッシュトークンを管理し、BFF へのリクエストヘッダ付与を共通化する。
- UI レイヤーはドメイン知識を BFF との GraphQL 契約内にとどめ、直接リードモデル DB やコマンドサービスへアクセスしない。

## 8. セキュリティ要件
- BFF とコマンドアプリケーションサービス間、BFF と MySQL/Redis 間の通信には TLS を適用し、ネットワーク境界で最小権限を徹底する。
- OIDC トークン検証結果を GraphQL コンテキストに埋め込み、認可判定や監査ログに活用する。
- イベントストア・リードモデル DB・Redis へのアクセス権は IAM ロールやセキュリティグループで制限し、機密情報は保存時暗号化を適用する。
- 監査ログ・アクセスログ・イベント処理ログを一元化し、SIEM との連携を想定したフォーマットで出力する。

## 9. 非機能要件
- 読み取り系 GraphQL Query はミリ秒オーダーのレスポンスを目標とし、Subscription の遅延も同等レベルに抑える。コマンド処理はドメイン検証を含めても秒単位以内で応答する。
- BFF、コマンドアプリケーションサービス、リードモデル更新サービスはいずれもコンテナ化し、CI/CD パイプラインでデプロイを自動化する。
- 監視指標（GraphQL レイテンシ、Subscription 接続数、イベント処理遅延、コマンド成功率、エラー分類）を定義し、ダッシュボード化する。
- 障害時にはイベントリプレイやスナップショット復元により RPO を数分以内に抑え、Redis などの通知基盤が停止した場合はフェイルセーフとしてポーリングや再フェッチ戦略を用意する。
- `specs/` 配下の仕様、`plan-template.md`、`tasks.md` を常に最新化し、実装との差異を許容しない。テストケースは受入条件とトレースできるよう整理する。
- ドメイン層・ユースケース層はテストファーストで実装し、コマンド→イベント→投影→GraphQL レイヤまでの E2E を自動化して回帰を防止する。
- BFF とコマンドアプリケーションサービスは独立スケールを前提とし、水平スケール時の接続管理（gRPC チャネル／HTTP コネクションプール）と障害分離を設計に反映する。

## 10. ガバナンスと開発プロセス遵守
- 新規・変更要件は OpenSpec ベースの `spec-template.md` に従い、ユースケース、受入基準、制約、エラー分類を明記した上で合意を得る。
- 仕様承認前に実装へ着手しない。憲章違反が疑われる場合は仕様段階で解決する。
- 機能開発はユースケース単位でモジュール化し、依存関係を「インターフェースアダプタ → ユースケース → ドメイン」へ限定する。
- 仕様・計画・タスク・実装間のトレーサビリティを確保し、コミットや PR には関連する仕様 ID とユースケース名を付記する。
- エラー分類は回復可能/不能を明確化し、`Result` 等で表現する。回復不能エラーはフェイルファスト戦略に従いログと監視で可視化する。

## 11. 今後の検討事項
- GraphQL Subscription の具体的なイベント種別・ペイロード設計、および Redis Streams 等を用いた再送戦略。
- マルチテナント要件や RBAC/ABAC の詳細設計と GraphQL スキーマへの組み込み方針。
- ローカル開発環境向けの DynamoDB Local / Kinesis エミュレーション、MySQL シード、Redis エミュレータの整備。
- Observability 強化のための OpenTelemetry 対応と分散トレーシング実装、GraphQL リゾルバ単位のメトリクス設計。
